package GameRuleLanguage.sandbox;

/*Generated by MPS */

import java.util.LinkedHashMap;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormat;
import java.util.Map;
import java.util.Set;
import java.util.Date;
import java.util.Optional;
import java.util.TreeMap;
import java.time.LocalDateTime;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

public class PointConcept extends GameConcept {
  private Double score = 0.0;


  private LinkedHashMap<String, PeriodInternal> periods = new <String,PeriodInternal>LinkedHashMap();
  public DateTimeFormatter PERIOD_KEY_FORMAT = DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss");
  /*package*/ long executionMoment = System.currentTimeMillis();
  public PointConcept(String name, long moment) {
    super(name);
    executionMoment = moment;
  }

  public PointConcept(String name) {
    super(name);
  }

  public PointConcept(Map<String, Object> jsonProps) {
    super(jsonProps);
    if (jsonProps != null) {
      Object scoreField = jsonProps.get("score");
      // fix: in some case PointConcept JSON representation contains 0 
      // value 
      // in score field 
      // and so it is cast to Integer 
      if (scoreField != null) {
        if (scoreField instanceof Double) {
          score = (Double) scoreField;
        }
        if (scoreField instanceof Integer) {
          score = ((Integer) scoreField).doubleValue();
        }
      }
      Map<String, Object> temp = (Map<String, Object>) jsonProps.get("periods");
      if (temp != null) {
        Set<Map.Entry<String, Object>> entries = temp.entrySet();
        for (Map.Entry<String, Object> entry : entries) {
          periods.put(entry.getKey(), new PeriodInternal((Map<String, Object>) entry.getValue()));
        }
      }
    }
  }

  public Period getPeriod(String periodName) {
    return periods.get(periodName);
  }

  public Map<String, PeriodInternal> getPeriods() {
    return periods;
  }

  public void setPeriods(Map<String, PeriodInternal> periods) {
  }

  public Double getScore() {
    return score;
  }

  public void setScore(Double score) {
    increasePeriodicPoints(score - this.score);
    this.score = score;
  }

  public Double increment(Double score) {
    increasePeriodicPoints(score);
    this.score += score;
    return this.score;
  }

  private void increasePeriodicPoints(Double score) {
    for (PeriodInternal p : periods.values()) {
      p.increaseScore(score, executionMoment);
    }
  }

  public void addPeriod(String identifier, Date start, long period) {
    PeriodInternal p = new PeriodInternal(identifier, start, period);
    storePeriod(identifier, p);
  }

  private void storePeriod(String identifier, PeriodInternal period) {
    if (!(periods.containsKey(identifier))) {
      periods.put(identifier, period);
    }
  }

  public void addPeriod(String identifier, Date start, Date end, long period) {
    PeriodInternal p = new PeriodInternal(identifier, start, end, period);
    storePeriod(identifier, p);
  }

  public void addPeriod(String identifier, Date start, long period, int capacity) {
    PeriodInternal p = new PeriodInternal(identifier, start, period, capacity);
    storePeriod(identifier, p);
  }

  public void deletePeriod(String identifier) {
    periods.remove(identifier);
  }

  public Double getPeriodCurrentScore(int periodIndex) {
    return null;
  }

  public Double getPeriodCurrentScore(String periodIdentifier) {
    return (periods.containsKey(periodIdentifier) ? periods.get(periodIdentifier).getCurrentScore() : 0.0);
  }

  public PeriodInstance getPeriodCurrentInstance(int periodIndex) {
    return null;
  }

  public PeriodInstance getPeriodCurrentInstance(String periodIdentifier) {
    return (periods.containsKey(periodIdentifier) ? periods.get(periodIdentifier).getCurrentInstance() : null);
  }

  public Double getPeriodPreviousScore(String periodIdentifier) {
    PeriodInstance previous = getPeriodPreviousInstance(periodIdentifier);
    return (previous != null ? previous.getScore() : 0.0);
  }

  public PeriodInstance getPeriodPreviousInstance(String periodIdentifier) {
    int currentIndex = getCurrentInstanceIndex(periodIdentifier);
    return (currentIndex != -1 ? getPeriodInstance(periodIdentifier, currentIndex - 1) : null);
  }

  public Double getPeriodScore(String periodIdentifier, long moment) {
    return (periods.containsKey(periodIdentifier) ? periods.get(periodIdentifier).getScore(moment) : 0.0);
  }

  public PeriodInstance getPeriodInstance(String periodIdentifier, long moment) {
    return (periods.containsKey(periodIdentifier) ? periods.get(periodIdentifier).retrieveInstance(moment) : null);
  }

  private int getCurrentInstanceIndex(String periodIdentifier) {
    PeriodInstance current = getPeriodCurrentInstance(periodIdentifier);
    return (current != null ? current.getIndex() : -1);
  }

  public Double getPeriodScore(String periodIdentifier, int instanceIndex) {
    Double result = 0.0;
    PeriodInternal p = periods.get(periodIdentifier);
    if (p != null) {
      PeriodInstance instance = getPeriodInstance(periodIdentifier, instanceIndex);
      result = (instance != null ? instance.getScore() : 0.0);
    }
    return result;
  }

  /**
   * The method returns the PeriodInstance relative to the index.
   * 
   * @param periodIdentifier
   *            identifier of period
   * @param instanceIndex
   *            index of instance
   * @return PeriodInstance bound to the index or null if there is not
   *         PeriodInstance at that index
   */
  public PeriodInstance getPeriodInstance(String periodIdentifier, int instanceIndex) {
    PeriodInstance result = null;
    return result;
  }
  public interface Period {
    Date getStart();
    Optional<Date> getEnd();
    long getPeriod();
    String getIdentifier();
    int getCapacity();
  }
  public interface PeriodInstance {
    Double getScore();
    long getStart();
    long getEnd();
    int getIndex();
  }
  private class PeriodInternal implements Period {
    private Date start;
    private Optional<Date> end;
    private long period;
    private String identifier;
    private int capacity;
    private TreeMap<LocalDateTime, PeriodInstanceImpl> instances = new TreeMap();
    public PeriodInternal(String identifier, Date start, long period) {
      this.start = start;
      this.end = Optional.empty();
      this.period = period;
      this.identifier = identifier;
    }
    public PeriodInternal(String identifier, Date start, long period, int capacity) {
      this(identifier, start, period);
      this.capacity = capacity;
    }
    public PeriodInternal(String identifier, Date start, Date end, long period) {
      this.start = start;
      this.end = Optional.ofNullable(end);
      this.period = period;
      this.identifier = identifier;
    }
    public PeriodInternal(String identifier, Date start, Date end, long period, int capacity) {
      this(identifier, start, end, period);
      this.capacity = capacity;
    }
    public PeriodInternal(Map<String, Object> jsonProps) {
      if (jsonProps != null) {
        Object startField = jsonProps.get("start");
        if (startField != null) {
          start = new Date((long) startField);
        }
        Object endField = jsonProps.get("end");
        end = Optional.ofNullable((endField == null ? null : new Date((long) endField)));
        Object periodField = jsonProps.get("period");
        if (periodField != null) {
          if (periodField instanceof Long) {
            period = (Long) periodField;
          }
          if (periodField instanceof Integer) {
            period = Integer.valueOf((Integer) periodField).longValue();
          }
        }
        identifier = (String) jsonProps.get("identifier");
        Object capacityField = jsonProps.get("capacity");
        if (capacityField != null) {
          capacity = (int) capacityField;
        }
        Map<String, Map<String, Object>> tempInstances = (Map<String, Map<String, Object>>) jsonProps.get("instances");
        if (tempInstances != null) {
          Set<Map.Entry<String, Map<String, Object>>> entries = tempInstances.entrySet();
          for (Map.Entry<String, Map<String, Object>> entry : entries) {
          }
        }
      }
    }
    private PeriodInstanceImpl getCurrentInstance() {
      return retrieveInstance(executionMoment);
    }
    public Double getCurrentScore() {
      try {
        return getCurrentInstance().getScore();
      } catch (IllegalArgumentException e) {
        return 0.0;
      }
    }
    public Double getScore(long moment) {
      try {
        return retrieveInstance(moment).getScore();
      } catch (NullPointerException e) {
        return 0.0;
      }
    }
    public Double increaseScore(Double value, long moment) {
      try {
        PeriodInstanceImpl instance = retrieveInstance(moment);
        return instance.increaseScore(value);
      } catch (IllegalArgumentException e) {
        return 0.0;
      }
    }
    private PeriodInstanceImpl retrieveInstance(long moment) {
      return null;
    }
    public Date getStart() {
      return start;
    }
    public void setStart(Date start) {
      this.start = start;
    }
    public long getPeriod() {
      return period;
    }
    public void setPeriod(long period) {
      this.period = period;
    }
    public TreeMap<LocalDateTime, PeriodInstanceImpl> getInstances() {
      return instances;
    }
    public void setInstances(TreeMap<LocalDateTime, PeriodInstanceImpl> instances) {
      this.instances = instances;
    }
    public void setIdentifier(String identifier) {
      this.identifier = identifier;
    }
    public String getIdentifier() {
      return identifier;
    }
    @Override
    public int getCapacity() {
      return capacity;
    }
    public int setCapacity(int capacity) {
      return this.capacity = capacity;
    }
    public Optional<Date> getEnd() {
      return end;
    }
    public void setEnd(Optional<Date> end) {
      this.end = end;
    }
  }
  private class PeriodInstanceImpl implements PeriodInstance {
    private Double score = 0.0;
    private long start;
    private long end;
    private int index;
    public PeriodInstanceImpl(long start, long end) {
      this.start = start;
      this.end = end;
    }
    public PeriodInstanceImpl(Map<String, Object> jsonProps) {
      Object scoreField = jsonProps.get("score");
      Object startField = jsonProps.get("start");
      Object endField = jsonProps.get("end");
      Object indexField = jsonProps.get("index");
      if (scoreField != null) {
        if (scoreField instanceof Double) {
          score = (Double) scoreField;
        }
        if (scoreField instanceof Integer) {
          score = Integer.valueOf((Integer) scoreField).doubleValue();
        }
      }
      if (startField != null) {
        if (startField instanceof Long) {
          start = (Long) startField;
        }
        if (startField instanceof Integer) {
          start = Integer.valueOf((Integer) startField).longValue();
        }
      }
      if (endField != null) {
        if (endField instanceof Long) {
          end = (Long) endField;
        }
        if (endField instanceof Integer) {
          end = Integer.valueOf((Integer) endField).longValue();
        }
      }
      if (indexField != null) {
        if (indexField instanceof Integer) {
          index = Integer.valueOf((Integer) indexField);
        }
      }
    }
    public Double increaseScore(Double value) {
      score = score + value;
      return score;
    }
    public Double getScore() {
      return score;
    }
    public void setScore(Double score) {
      this.score = score;
    }
    public long getStart() {
      return start;
    }
    public void setStart(long start) {
      this.start = start;
    }
    public long getEnd() {
      return end;
    }
    public void setEnd(long end) {
      this.end = end;
    }
    @Override
    public String toString() {
      DateFormat formatter = new SimpleDateFormat("dd/MM/yyyy HH:mm");
      return String.format("[start: %s, end: %s, score: %s, index: %s]", formatter.format(new Date(start)), (end > -1 ? formatter.format(new Date(end)) : "-"), score, index);
    }
    public int getIndex() {
      return index;
    }
    public void setIndex(int index) {
      this.index = index;
    }
  }
  public long getExecutionMoment() {
    return executionMoment;
  }

  public void setExecutionMoment(long executionMoment) {
    this.executionMoment = executionMoment;
  }

  @Override
  public boolean equals(Object obj) {
    if (obj instanceof PointConcept) {
      PointConcept toCompare = (PointConcept) obj;
      return toCompare == this || name.equals(toCompare.name);
    }
    return false;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  @Override
  public String toString() {
    return String.format("{name: %s, score: %s}", name, score);
  }
}
